services:
  booking_db:
    restart:
      unless-stopped
    image:
      postgres:16
#    ports:
#      - '6432:5432'
    networks:
      - booking_network
    environment:
      - POSTGRES_USER
      - POSTGRES_PASSWORD
      - POSTGRES_DB
    # will take them from default .env file
    volumes:
      - pg-booking-data:/var/lib/postgresql/data
#    healthcheck:   # will run forever
#      test: [ "CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB" ]
#      interval: 0.01s
#      retries: 10000

  booking_cache:
    restart:
      unless-stopped
    image:
      redis:7.4
    networks:
      - booking_network

  booking_nginx:
    restart:
      always
    image:
      nginx
    networks:
      - booking_network
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./certbot/www/:/var/www/certbot/:ro   # step 1: certbot will use it for verifications
      - ./certbot/conf/:/etc/nginx/ssl/:ro    # step 2: after certbot certonly run (see in .md) certs will be here
    depends_on:
      - booking_back

  certbot:
    image: certbot/certbot:latest
    networks:
      - booking_network
    volumes:
      - ./certbot/www/:/var/www/certbot/:rw
      - ./certbot/conf/:/etc/letsencrypt/:rw

volumes:
  pg-booking-data:

networks:
  booking_network:

# default network with type bridge will be created
# network and containers outer names start with current folder name

# docker volume rm  fastapi_arsh_pg-booking-data [folder-name+volume]
# docker-compose up --build (to rebuild with changed ENV)

# docker volume ls | grep booking
# docker network ls (fastapi_arsh_default)

# [instead of forever healthcheck on first startup:]
# docker-compose run --rm booking_db to initialize DB and create volume first time, then stop and up (?)

# docker-compose run --rm certbot certonly --webroot --webroot-path /var/www/certbot/ --dry-run -d [domain-name]
# docker-compose run --rm certbot renew
# details in dockers_etc_info.md

# ___
# docker compose -f docker-compose-etc up
